*Sources*: YouTube (Durga software solutions); documentation (oracle docs: JVM Specification for Java SE 8 Edition); images (Google JVM architecture)
# Index:
1. General info 
2. JVM architecture
	1. JVM components 
		1. Class Loader
			1. Loading
			2. Linking
				1. Verification
				2. Preparation
				3. Resolution
			3. Initialization
			4. Types of class loaders: 
				1. bootstrap class loader
				2. extension class loader or new Platform class loader
				3. application class loader
		2. Memory Area (Runtime Data Areas)
		3. Execution Engine
	2. JVM component diagram 
# General info
- Java is both compiled and interpreted. JDK compiles while interpretation occurs in JRE. 
- first of all, .Java file is there. Java compiler (Javac) will generate Java class file. Javac Java compiler is located in JDK, not JRE or JVM. 
- .Java file is compiled into .class file. The .class file is fed to JVM. 
- JDK = JRE + development tools; JRE = JVM + library classes
- if I develop .class file and give to client, the client machine must have JRE.

# JVM architecture 
- 2 types of VM: hardware based and software based. VM are also called hypervisors. Bare metal hypervisor means hardware based vm.
- JVM is responsible to run Java application. JVM is an interpreter because it executes the code line by line
- JVM has 3 parts: **class loader, memory area and execution engine.**
## The Java Virtual Machine (JVM) has three primary components:

1. ***==Class Loader==***: Responsible for loading Java classes into memory when they are needed. It checks if the class is already loaded and, if not, loads the class file into the JVM. The class loader also handles tasks like verification, preparation, and resolving of the classes.
	- note: Although default classloader in JVM is excellent, if we want, we can create a custom class loader (created by user) to suit our needs. 
	- CL subsystem is responsible for 3 activities: loading, linking, initialization. 
		- Loading : it means read .class file from hdd or SSD (machines ROM) and store the machine code (binary data) of .class file inside method area of JVM. 
			- for each class file, JVM will store the following into method area: 
				- qualified name of class
				- name of immediate parent
				- whether class file represents class/interface/enum
				- methods /constructors/ variables information 
				- modifiers information 
				- constant pool info 
			- after loading every .class file, JVM will create an object of  class Class file. the programmer can use class Class object to access class level binary information. 
			- the objects created in the above point will be stored in a heap area. the object is not a student object if the class name was student.class. the object is strictly a class Class object. its vague. the programmer can write a program to display names of all methods in student.class using the class Class object. refer CODE 1 for more details
		- Linking: this step consists of 3 activities. verification, preparation, resolution. 
			- verification: is .class file formatted in a correct way?
				- java is secure because there is a special component in JVM called Byte Code Verifier, this component is part of class loader subsystem. we never get virus from .class file due to this component. 
				- if the component finds any virus or malware activity in the file, the component will throw a verifyerror runtime error. exact error: java.lang.VerifyError
				- verification ensures that binary representation fo a class is structurally correct or not.also it checks whether .class file is generated by valid compiler or not. 
			- Preparation: in this phase, JVM will allocate memory for class level static variables and assign them default values. for eg: int - 0, double - 0.0, boolean - false and so on. 
				- note: in preparation phase, only default values will be allocated. the actual values associated with variables will be allocated in initialization phase.
			- Resolution: java language is programmer friendly, not machine friendly. In resolution phase, it is the process of replacing all symbolic references used in our class with original direct references from method area. in short replacing symbols in the code with actual original reference in method area. 
				- eg: String s = new String("akash") and String s2 = new String("kamat"). for the above class, classLoader sybsystem loads test.class, String.class, object.class and so on. for every class file symbol, JVM will maintain a constant pool. if there are 3 string symbols in the code, the name of these class are stored in constant pool of the code class, lets say test class. 
				- in resolution phase, these symbols are replaced with actual reference in method area. 
				- the programmer will never need to get involved in these above procedures. these are only to make java more machine friendly :) and all these procedures are done by JVM internally.
		- Initialization: for class level static variables, JVM will assign original values and static class execution will be performed from top to bottom. just as discussed in preparation phase above where only default values were allocated, here in initialization, if int a= 10, 10 value will be assigned to the static variable named 'a'. thats it for initialization. 
	- if during any of the above 3 steps of loading, linking and initialization, error occurs, the runtime error: java.lang.LinkageError is thrown. the VerifyError from verification failure is a subset of linkageError.
	- Types of Class Loaders CL: bootstrap cl, extension cl, application cl. 
		- bootstrap cl: responsible to load from bootstrap class path. usually in java applications, internally JVM use rt.jar. Core java API classes like string, stringbuffer, map, java.lang package, etc are available inside rt.jar. and the location is considered as bootstrap class path. 
			- bootstrap Class loader is responsible to load all core java api classes from rt.jar.
			- JDK->JRE->lib->rt.jar this is called bootstrap class path. 
			- with every JVM, this bootstrap cl is there by default. bootstrap cl is not implemented in java, most of the time it is implemented in native languages like c/cpp. it is os sensitive (changes according to os internally, which is why we have different JDK for linux, mac, windows etc)
		- extension cl: child of bootstrap classloader
			- responsible for loading classes from extension class path. 
			- JDK->JRE->lib->ext->any .jar file. in this path(extension class path), any *.jar file is loaded by extension class loader.
			- extension cl is implemented in java, its a java object. the corresponding class name to extension class loader is sun.misc.Launcher$ExtClassLoader. 
			- extension class loader is deprecated from java version 9. **Platform ClassLoader**: Replaces the Extension ClassLoader and loads platform-specific modules (e.g., JavaFX and other APIs outside the core `java.base` module).
		- Application cl: child of extension class loader
			- load classes from application class path. like test class, student class, customer class etc. the classes that are on user level or application level defined by the user. 
			- corresponding class name for application cl is: sun.misc.Launcher$AppClassLoader.Class
	- How does Java classloader works:
		- CL follows delegation hierarchy algorithm 
		- whenever JVM comes across a .class file, it checks if the .class file is loaded or not. If loaded already, the JVM will use the class file from the loaded method area. 
		- if not the JVM sends request to load to class loader subsystem. The CL subsystem sends the request to find .class file to application class loader, the app cl delegates the task to extension cl. Extension cl will again delegate to bootstrap classloader. Bootstrap cl will search bootstrap bootstrap class path. The path is given in above points. If not in bscl, the bootstrap cl will delegate to extension cl which will search extension class path. Even if extension cl didn't find, it will ask app cl to search in application class path. This whole process of delegation is called delegation hierarchy algorithm.
		- in delegation hierarchy algorithm, highest priority is given to bootstrap cl then extension cl then application cl.
		- ![image](https://github.com/user-attachments/assets/4d6e6711-6bb0-42ed-8eba-e2fd0ca083c5)

``` 
// CODE 1
//java program that uses class Class object for more info.
import java.lang.reflect.Method;
public class Main {

    // Define the Student class
    static class Student {
        public void study() {
            System.out.println("Studying...");
        }

        public void play() {
            System.out.println("Playing...");
        }
    }

    public static void main(String[] args) {
        // Create a Class object for Student class
        Class<?> studentClass = Student.class;

        // Retrieve all methods in the Student class
        Method[] methods = studentClass.getDeclaredMethods();

        // Print the name of each method
        System.out.println("Methods in Student class:");
        for (Method method : methods) {
            System.out.println(method.getName());
        }
    }
}
```

2. ***==Memory Area (Runtime Data Areas)==***: This is where the JVM allocates memory for different parts of the program during execution. Key areas include: 
	- **Heap**: Where objects are stored.
	- **Stack**: Stores method frames, local variables, and method call information. For every thread, separate runtime stack will be created. Each entry in a stack is called stack frame. Each stack frame contain 3 parts: local variable array, frame data, operand status. 
	- **Method Area**: Stores class structures, including the runtime constant pool and method code.
	- **PC Register**: Holds the address of the current instruction. Each thread has their own pc registers Inside pc register area. 
	- **Native Method Stack**: Used for native method calls (methods written in languages like C). For every thread, separate native method stack is there. 

3. ***==Execution Engine==***: Responsible for executing the bytecode. It converts the Java bytecode into machine code that the underlying hardware can understand. The execution engine includes:
	- execution area communicates with various memory areas of JVM
	- parte of execution engine: 
		- **Interpreter**: Interprets bytecode instructions one by one.
		- **Just-In-Time (JIT) Compiler**: Compiles bytecode into machine code for faster execution, optimizing frequently used code. Further parts of JIT:
			- Intermediate code generator: produces intermediate code. 
			- Code optimiser: optimises the above intermediate code. 
			- Target code generator: responsible to generate machine code. 
			- profiler
		- **Garbage Collector**: Automatically manages memory by deallocating objects that are no longer in use.

Another component in JVM is Java native interface(JNI) which is responsible for providing native method libraries. Although it's not counted as a proper JVM component, awareness is necessary. 

In summary, these three parts (Class Loader, Memory Area, and Execution Engine) form the core of the JVM and ensure Java programs are loaded, executed, and managed efficiently.

## JVM component diagram 

![image](https://github.com/user-attachments/assets/46ac725a-f32d-4fd0-be4c-e4e1ccaff8fe)
