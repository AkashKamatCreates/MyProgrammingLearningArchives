| Data Structure | Time Complexity (Average Case) | Short Description | Use Case | Real Life Example | Pros | Cons | Non-Primitive Implementation |
| --- | --- | --- | --- | --- | --- | --- | --- |
| **Array** | Access: O(1), Search: O(n), Insertion: O(n), Deletion: O(n) | A collection of items stored at contiguous memory locations[^1^][1] | When you need fast access to elements based on their index[^1^][1] | Storing data in tabular format[^2^][21] | Fast access, Memory efficient[^1^][1] | Fixed size, Insertion and deletion can be slow[^1^][1] | `java.util.ArrayList`, `java.util.Vector` |
| **String** | Access: O(1), Search: O(n), Insertion: O(n), Deletion: O(n) | A sequence of characters[^1^][1] | When you need to store and manipulate text[^1^][1] | Storing and manipulating text in any text editor[^1^][1] | Easy to use, Can be indexed like arrays[^1^][1] | Immutable in some languages, Operations can be slow for large strings[^1^][1] | `java.lang.String`, `java.lang.StringBuilder`, `java.lang.StringBuffer` |
| **Singly LinkedList** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | A linear data structure where each element points to the next[^1^][1] | When you need to perform frequent insertions and deletions[^1^][1] | Music playlist, where each song is linked to the next one[^3^][23] | Dynamic size, Easy insertion/deletion[^1^][1] | Slower access, More memory[^1^][1] | `java.util.LinkedList` |
| **Doubly LinkedList** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | Similar to singly linked list, but each node points to both the next node and the previous node[^1^][1] | When you need to perform frequent insertions and deletions and need to traverse in both directions[^1^][1] | Web browser history, where each page is linked to the next and the previous page[^1^][1] | Dynamic size, Easy insertion/deletion, Can be traversed in both directions[^1^][1] | Slower access, More memory[^1^][1] | `java.util.LinkedList` |
| **Circular LinkedList** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | Similar to singly linked list, but the last node points to the first node[^1^][1] | When you need to represent data in a circular fashion (like a round-robin scheduler)[^1^][1] | CPU scheduling[^1^][1] | Dynamic size, Easy insertion/deletion, Can be traversed from tail to head[^1^][1] | Slower access, More memory[^1^][1] | Custom implementation required |
| **Stack** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | A linear data structure that follows the LIFO principle[^4^][6] | When you need to access elements in LIFO order[^4^][6] | Backtracking algorithms, Undo functionality in text editors[^4^][6] | Fast operations, Simple to implement[^4^][6] | Limited access (only top element), Can overflow if size limit is reached[^4^][6] | `java.util.Stack`, `java.util.Deque` |
| **Queue** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | A linear data structure that follows the FIFO principle[^5^][7] | When you need to access elements in FIFO order[^5^][7] | Line for a cashier, Print spooler[^5^][7] | Fast operations, Simple to implement[^5^][7] | Limited access (only front element), Can overflow if size limit is reached[^5^][7] | `java.util.Queue`, `java.util.LinkedList`, `java.util.PriorityQueue` |
| **Heap** | Access: O(n), Search: O(n), Insertion: O(log n), Deletion: O(log n) | A complete binary tree that satisfies the heap property[^1^][1] | When you need to quickly find the smallest (min-heap) or largest (max-heap) element[^1^][1] | Priority Queue, Dijkstra's algorithm[^1^][1] | Fast insertion and deletion, Can quickly find min or max element[^1^][1] | Slower access and search, More complex to implement[^1^][1] | `java.util.PriorityQueue` |
| **Tree** | Access: O(log n), Search: O(log n), Insertion: O(log n), Deletion: O(log n) | A hierarchical data structure with a set of connected nodes without cycles[^1^][1] | When you need to represent hierarchical relationships[^1^][1] | File systems, HTML DOM[^1^][1] | Fast operations, Can represent hierarchy[^1^][1] | More complex to implement, More memory[^1^][1] | `java.util.TreeSet`, `java.util.TreeMap` |
| **Graph** | Depends on the type of graph and the specific operation | A collection of vertices (nodes) and edges that represent relationships between the vertices[^1^][1] | When you need to represent relationships between pairs of elements[^1^][1] | Social networks, Web pages[^1^][1] | Can represent complex relationships, Flexible structure[^1^][1] | More complex to implement and traverse, More memory[^1^][1] | Custom implementation required |
| **Trie** | Access: O(k), Search: O(k), Insertion: O(k), Deletion: O(k) | A tree-like data structure that stores a collection of strings[^6^][4] | When you need to store a collection of strings and perform efficient searching[^6^][4] | Autocomplete feature in search engines[^6^][4] | Fast operations, Can quickly find strings with a common prefix[^6^][4] | Takes a lot of memory[^7^][16] | Custom implementation required |
