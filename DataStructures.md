| Data Structure | Time Complexity (Average Case) | Use Case | Pros | Cons |
| --- | --- | --- | --- | --- |
| **Array** | Access: O(1), Search: O(n), Insertion: O(n), Deletion: O(n) | When you need fast access to elements based on their index | Fast access, Memory efficient | Fixed size, Insertion and deletion can be slow |
| **String** | Access: O(1), Search: O(n), Insertion: O(n), Deletion: O(n) | When you need to store and manipulate text | Easy to use, Can be indexed like arrays | Immutable in some languages, Operations can be slow for large strings |
| **Singly LinkedList** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | When you need to perform frequent insertions and deletions | Dynamic size, Easy insertion/deletion | Slower access, More memory |
| **Doubly LinkedList** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | When you need to perform frequent insertions and deletions and need to traverse in both directions | Dynamic size, Easy insertion/deletion, Can be traversed in both directions | Slower access, More memory |
| **Circular LinkedList** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | When you need to represent data in a circular fashion (like a round-robin scheduler) | Dynamic size, Easy insertion/deletion, Can be traversed from tail to head | Slower access, More memory |
| **Stack** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | When you need to access elements in LIFO order | Fast operations, Simple to implement | Limited access (only top element), Can overflow if size limit is reached |
| **Queue** | Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1) | When you need to access elements in FIFO order | Fast operations, Simple to implement | Limited access (only front element), Can overflow if size limit is reached |
| **Heap** | Access: O(n), Search: O(n), Insertion: O(log n), Deletion: O(log n) | When you need to quickly find the smallest (min-heap) or largest (max-heap) element | Fast insertion and deletion, Can quickly find min or max element | Slower access and search, More complex to implement |
| **Tree** | Access: O(log n), Search: O(log n), Insertion: O(log n), Deletion: O(log n) | When you need to represent hierarchical relationships | Fast operations, Can represent hierarchy | More complex to implement, More memory |
| **Graph** | Depends on the type of graph and the specific operation | When you need to represent relationships between pairs of elements | Can represent complex relationships, Flexible structure | More complex to implement and traverse, More memory |
| **Trie** | Access: O(k), Search: O(k), Insertion: O(k), Deletion: O(k) | When you need to store a collection of strings and perform efficient searching | Fast operations, Can quickly find strings with a common prefix | Takes a lot of memory |
